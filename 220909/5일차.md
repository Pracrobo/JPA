CRUD 정리 : java Collection에 데이터를 넣었다 뺐다 하는 것처럼 만듦
 - 저장 : jpa.persist(member)
 - 조회 : Member member = jpa.find(memberId)
 - 수정 : member.setName("변경할 이름")
 - 삭제 : jpa.remove(member)

## 연관관계 사용
1. 저장
 : 모든 엔티티는 영속 상태여야 한다.
2. 조회 : 
- 객체 그래프 탐색( 객체 연관관계를 사용한 조회)
- 객체 지향 쿼리를 사용한다.(JPQL)


## JPA의 성능 최적화 기능
: 중간 계층이 있는 경우 아래의 방법으로 성능을 개선할 수 있는 기능이 존재한다.
 - 모아서 쓰는 버퍼링 기능
 - 읽을 때 쓰는 캐싱 기능

1) 1차 캐시와 동일성 보장 :캐싱 기능 : 1차 캐시에 있는 엔티티를 조회한다.( em.find() 호출)
   1) 같은 트랜잭션 안에서는 같은 엔티티를 반환 : 약간의 조회 성능을 향상시키는데 크게 도움되지 않는다.
   ** 결과적으로 SQL 을 한번만 실행한다.
   2) DB Isolation Level 이 Read Commit 이어도 애플리케이션에서 Repeatable Read 보장한다.
2) 트랜잭션을 지원하는 쓰기  지연 : 버퍼링 기능
- INSERT
    1) JDBC Batch SQL 기능을 사용해서 한번에 SQL을 전송한다.
    - JDBC Batch를 사용하면 코드가 굉장히 지저분해지고
    - 지연로딩전략(Lazy Loading) 옵션을 사용한다.
- UPDATE
    1) UPDATE, DELETE 로 인한 로우(ROW)락 시간 최소화
    2) 트랜잭션  커밋시 UPDATE, DELETE SQL 실행하고 바로 커밋한다.
3) 지연 로딩
    - 객체가 실제로 사용될 때 로딩하는 전략


4) 즉시 로딩
 - JOIN SQL로 한번에 연관된 객체까지 미리 조회하는 전략
 - join 을 통해 항상 연관된 모든 객체를 같이 가져온다.


## 업데이트 기본 전략
- JPA의 기본 전략은 모든 필드를 업데이트한다.
- 모든 필드를 사용하면 수정쿼리가 항상 같다
- 동일한 쿼리를 보내면 데이터베이스는 이전에 파싱된 쿼리는 재사용한다.

## 필드가 많거나 저장되는 내용이 큰 경우에 하이버네이트 확장 기능을 사용한다.
@Entity <br>
@org.hibernate.annotation.DynamicUpdate<br>
@Table(name ="Member") <br>
public class Member {...}

수정된 데이터만 사용해서 동적으로 UPDATE SQL을 생성

## 엔티티 삭제
- 삭제할 엔티티 조회
- em.remove(member)
- 바로 삭제가 아닌 삭제 쿼리를 쓰기 지연 SQL 저장소에 등록한다.
- em.remove(member)를 호출하는 순간 영속성 컨텍스트에서 제거된다.





요약집 홈페이지 : https://ultrakain.gitbooks.io/jpa/content/
